// admin-backend/backend/routes/aira.js (CommonJS)
const express = require('express');
const fs = require('fs/promises');
const path = require('path');
const crypto = require('crypto');
const openaiClient = require('../../openaiClient.js');
const cron = require('node-cron');

const router = express.Router();

const ROOT = path.resolve(__dirname, '..');
const DATA_DIR = path.join(ROOT, 'data');
const UPLOADS_DIR = path.resolve(__dirname, '../../uploads');
const BULLETINS_DIR = path.join(UPLOADS_DIR, 'bulletins');
const DATA_FILE = path.join(DATA_DIR, 'aira-bulletins.json');

async function ensureDirs() {
  await fs.mkdir(DATA_DIR, { recursive: true });
  await fs.mkdir(BULLETINS_DIR, { recursive: true });
}
async function readJsonSafe(filePath, fallback) {
  try { const raw = await fs.readFile(filePath, 'utf8'); return JSON.parse(raw || ''); }
  catch { return fallback; }
}
async function writeJson(filePath, data) {
  await fs.writeFile(filePath, JSON.stringify(data, null, 2), 'utf8');
}
async function unlinkSafe(p) {
  try { await fs.unlink(p); } catch {}
}

async function runChat({ system, user, temperature = 0.5, max_tokens = 700 }) {
  const MODEL = process.env.OPENAI_MODEL || 'gpt-4o-mini';
  const completion = await openaiClient.chat.completions.create({
    model: MODEL,
    messages: [
      { role: 'system', content: system },
      { role: 'user', content: user },
    ],
    temperature,
    max_tokens,
  });
  const message = completion.choices?.[0]?.message?.content?.trim() || '';
  return { message, model: completion.model, usage: completion.usage };
}

// GET /api/aira/bulletins
router.get('/bulletins', async (_req, res) => {
  try {
    await ensureDirs();
    const db = await readJsonSafe(DATA_FILE, { items: [] });
    const items = Array.isArray(db.items) ? db.items : [];
    items.sort((a, b) => (b.ts || 0) - (a.ts || 0));
    res.json({ ok: true, items });
  } catch (err) {
    res.status(500).json({ ok: false, error: 'READ_FAILED', detail: err?.message || String(err) });
  }
});

async function generateBulletin({ lang = 'Gujarati', durationSec = 45, focus = '' } = {}) {
  await ensureDirs();
  const system = 'You are AIRA, NewsPulse\'s AI anchor. Write concise, engaging, factual voice bulletin scripts for radio/news audio. No emojis, no hashtags.';
  const user = `Create a ${Math.max(20, Math.min(90, Number(durationSec) || 45))}-second voice bulletin script in ${lang}. Tone: neutral, public-service broadcaster. \nContent focus (optional): ${focus || 'Top stories of the hour'}.\nRules: 3-5 crisp lines; anchor-ready; clear pronunciation cues if needed; end with the outlet sign-off. Return JSON ONLY as {"title":"...","script":"..."}.`;
  const { message, model, usage } = await runChat({ system, user, temperature: 0.4, max_tokens: 500 });
  let parsed;
  try { parsed = JSON.parse(message); } catch {
    const m = message && message.match && message.match(/\{[\s\S]*\}$/);
    if (m) { try { parsed = JSON.parse(m[0]); } catch (e) {} }
  }
  const title = (parsed && typeof parsed.title === 'string') ? parsed.title : 'AIRA Voice Bulletin';
  const script = (parsed && typeof parsed.script === 'string') ? parsed.script : message;
  const id = crypto.randomUUID();
  const ts = Date.now();
  const audioUrl = null; // TTS optional; not generated by default
  const db = await readJsonSafe(DATA_FILE, { items: [] });
  db.items = Array.isArray(db.items) ? db.items : [];
  const item = { id, ts, lang, title, script, audioUrl, model, usage };
  db.items.unshift(item);
  if (db.items.length > 200) db.items = db.items.slice(0, 200);
  await writeJson(DATA_FILE, db);
  return item;
}

// POST /api/aira/generate
// body: { lang?: 'Gujarati'|'Hindi'|'English', durationSec?: number, focus?: string }
router.post('/generate', async (req, res) => {
  try {
    const { lang = 'Gujarati', durationSec = 45, focus = '' } = req.body || {};
    const item = await generateBulletin({ lang, durationSec, focus });
    res.json({ ok: true, item, note: !item.audioUrl ? 'TTS not configured; client may use browser speech synthesis' : undefined });
  } catch (err) {
    console.error('‚ùå [/aira/generate] error:', err);
    const msg = err?.message || String(err);
    const isAuth = /incorrect api key|401|invalid_api_key/i.test(msg);
    const isRate = /rate limit|quota|429/i.test(msg) || err?.status === 429;
    res.status(isAuth ? 401 : isRate ? 429 : 500).json({ ok: false, error: isAuth ? 'AI_AUTH' : isRate ? 'AI_RATE_LIMIT' : 'AI_ERROR', detail: msg });
  }
});

// DELETE /api/aira/bulletins/:id
router.delete('/bulletins/:id', async (req, res) => {
  try {
    await ensureDirs();
    const id = String(req.params.id || '');
    const db = await readJsonSafe(DATA_FILE, { items: [] });
    db.items = Array.isArray(db.items) ? db.items : [];
    const idx = db.items.findIndex((x) => x && x.id === id);
    if (idx === -1) return res.status(404).json({ ok: false, error: 'NOT_FOUND' });
    const [removed] = db.items.splice(idx, 1);
    // best-effort delete local audio file if it exists under uploads
    if (removed && removed.audioUrl && typeof removed.audioUrl === 'string' && !/^https?:/i.test(removed.audioUrl)) {
      try {
        const rel = removed.audioUrl.replace(/^\/+/, '');
        const resolved = path.resolve(UPLOADS_DIR, rel.replace(/^uploads\//i, ''));
        if (resolved.startsWith(UPLOADS_DIR)) {
          await unlinkSafe(resolved);
        }
      } catch {}
    }
    await writeJson(DATA_FILE, db);
    res.json({ ok: true, removed: { id } });
  } catch (err) {
    res.status(500).json({ ok: false, error: 'DELETE_FAILED', detail: err?.message || String(err) });
  }
});

// Optional hourly cron (top of hour) if enabled
try {
  if (process.env.AIRA_CRON === '1') {
    cron.schedule('0 * * * *', async () => {
      try {
        await generateBulletin({ lang: process.env.AIRA_LANG || 'English', durationSec: Number(process.env.AIRA_DURATION || 45), focus: process.env.AIRA_FOCUS || '' });
        console.log('üïê AIRA bulletin generated by cron');
      } catch (e) {
        console.error('AIRA cron error:', e?.message || e);
      }
    });
    console.log('‚è±Ô∏è  AIRA hourly cron enabled');
  }
} catch {}

module.exports = router;
